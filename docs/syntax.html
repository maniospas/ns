<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NS language</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
	<link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
	<style>
    .sidebar {
      position: fixed;
	  width:200px;
      top: 12px;
      bottom: 0;
      left: 0px;
      z-index: 100;
      padding: 48px 0;
      background-color: #f8f9fa;
    }
	
	.navbar {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    .main-content {
      margin-left: 200px; /* Adjust this to match sidebar width */
      margin-top: 56px; /* Height of the navbar */
    }
	
	.smaller-font {
		margin-left: 10px;
		margin-top: -10px;
		font-size: 0.8em; /* Adjust the value as needed */
	}
  </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
	<a class="navbar-brand" href="#">
		<img src="ns.png" alt="NS" width="50">
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="navbarNav">
		<ul class="navbar-nav ml-auto">
			<li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="start.html">Get started</a></li>
			<li class="nav-item active"><a class="nav-link text-primary" href="syntax.html">Syntax</a></li>
			<li class="nav-item"><a class="nav-link" href="tutorials.html" data-page="tutorials">Tutorials</a></li>
		</ul>
	</div>
	</div>
</nav>


<div class="container main-content">
	

<div class="container-fluid mt-4">
  <div class="row">
    <!-- Sidebar -->
    <nav class="col-md-3 col-lg-2 d-md-block bg-white sidebar">
      <div class="position-sticky">
        <ul class="nav flex-column">
          <li class="nav-item">
            <a class="nav-link" href="#language-core">
              Language core
            </a>
            <ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#assignment-scope">Assignment scope</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#scopes-as-objects">Scopes as objects</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#define-expressions">Define expressions</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#scope-access">Scope access</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#common-expressions">
              Common expressions
            </a>
			<ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#io">I/O</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#control-flow">Control flow</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#running-files">Running files</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#errors">Errors</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#high-order-features">
              High order features
            </a>
			<ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#runtime-parsing">Runtime parsing</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#expression-overloading">Expression overloading</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#arithmetics">Metaprogramming</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#functional-programming">Functional programming</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#new-scope-files">
              Libraries
            </a>
			<ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#list">list.ns</a></li>
            </ul>
          </li>
		  
        </ul>
      </div>
    </nav>

    <!-- Main content -->
    <main class="col-md-9 ml-sm-auto col-lg-10 px-md-4">
	
      <div class="pt-3 pb-2 mb-3">
		<div class="jumbotron">
			<h1 class="display-4">NS syntax</h1>
		</div>
      </div>
      
      <section id="language-core">
        <h1>Language core</h1>
        <p>NS treats scopes, code blocks, and objects interchangeably. Thus, it lets a simple interface control powerful code design and self-modification options. The language has only a few core operations and keywords to remember.
		</p>
        <section id="assignment-scope">
          <h4>Assignment scope</h4>
		  <p>In NS, scopes are like blocks of code with clearly defined rules regarding which variables or programming commands they can access. Let's focus on setting and accessing variables for now with the := operation. Starting from a top-level scope, you can declare new scopes inside it, separated by semicolons. Scopes can be enclosed within brackets or parentheses. Parentheses can be omitted when running a single formula, such as assignment or printing. Bracketed scopes do not modify external variables unless they explicitly access them via objects. Here's an example:
		  </p>

<pre><code class="language-cpp">x := 0;
{
	x := 1;
	print(x); //0
};
print(x); //1
(
	x := 1;
	print(x); //0
);
print(x); //1</code></pre>
        
		<p>The last expression of scopes doesn't require a semicolon and serves as a returned value. Prefer bracketed scopes for safe assignments, but parentheses scopes have lower execution time overhead.</p>
		
<pre><code class="language-cpp">y = {
	x := 1;
	x
};
print(y); //1</code></pre>
		
        </section>
		
		
		<div class="alert alert-info" role="alert">
			Using expression definitions, which will be discussed later on, you can define your own assignment expressions, like x=y, and even overload them to change for different types of data.
		</div>
		
		
		
		

        <section id="scopes-as-objects">
          <h4>Scopes as objects</h4>
          <p>In NS, scopes can be treated like objects that hold their assigned variables. You can access object fields using the dot operator. This view is retrieved from the `new` variable. For example:</p>
<pre><code class="language-cpp">point = {
	x := 1;
	y := 2;
	new
};
print(point.x); //1
print(point.y); //1</code></pre>
		
		<p>All scopes have some additional variables that may modify their behavior (super, new, surface). Of these, `super` refers to the superscope, which is one level higher in the scope declaration hierarchy. When a variable is not found in a scope, it's retrieved from the superscope. 'new' refers to the scope itslef and can be returned to construct objects from scopes. For example:</p>
		
<pre><code class="language-cpp">z := 1;
point = {
	x:=z;
	y:=2;
	new
};
z := 0;
print(point.super.z); //0
print(point.x); //1
print(point.super.z); //1</code></pre>
        </section>
        
		
        <section id="define-expressions">
          <h4>Define expressions</h4>
          <p>NS supports expressions, that is, callable formulas. These define various predicate-based notations that include spaces and can have any number of positional arguments. Arguments are enclosed in parentheses, and the comma is treated as a shorthand for `()`. For instance, you can define a constructor for class objects like this:<p> 

<pre><code class="language-cpp">Point(x,y,z) := { // x, y, z automatically accessed from super
    new
};
point := Point(1,2,3);
print(point.x); //1
print(point.y); //2
print(point.z); //3
</code></pre>
		
		<div class="alert alert-info" role="alert">
			Variables are formulas without arguments that always output the same value.
		</div>

		<p>Formula implementations can be scoped in parentheses to transfer their internal assignments to the scope they are called from. For example:

<pre><code class="language-cpp">Point(x,y,z) := {
    norm squared:=x*x + y*y + z*z; 
    shrink(a) := (x:=x*a;y:=y*a;z:=z*a;); //to keep track of the last argument value within Point, also set a=a
    new
};
A = Point(0,0,1);
print(A.norm squared); //1
</code></pre>


		<p>Polymorphism of method-like expressions can be achieved by declaring new methods with different numbers of arguments. For example:</p>

<pre><code class="language-cpp">Point(x,y,z) := {new};
Point(x,y) := Point(x,y,0);
A = Point(1,1);
print(A.norm squared); //2
</code></pre>
	<p>Use objects to pass keyword arguments or arguments that you don’t want to remain in the object’s scope.</p>

        </section>
        
		
        <section id="scope-access">
          <h4>Scope access</h4>
          
		<p>Scope access in NS is a fundamental concept that allows you to interact with and manipulate scopes after their creation. Scope access can be performed with the operator :, or via supporting get and set methods. When you use a:b, it implies that you want to run the scope b within the scope represented by a. Here's an example of accessing a scope:</p>
		
<pre><code class="language-cpp">point = {
	x:=1;
	y:=2;
	new
};
point:x = 5; // the same as point.(x=5);
print(point:x); //5

point:(x=1; y=1;);
print(point.x); //1
print(point.y); //1

derived = point:{y=6;new}; //super of derived is the point
print(derived:x); //1
print(derived:y); //6
print(derived:super:x); //1</code></pre>
		
		<p>In the above scenarios, it is clear whose scope's variables are used to compute expressions. When the same expressions (including variable names) can be found both the scope being entered and the scope requesting access, the former's are used. The scope requesting access is stored in the `surface` variable. Here is an example:</p>
		
<pre><code class="language-cpp">x := 1;
a := {
	x := 0;
	new
};
print(a:x); //0
a:x=surface:x;  //equivalent to a:(x=surface:x);
print(a:x); //1
</code></pre>
		
	<p>As a more complicated example shows how to override a formula using the fallback operation;, it stores a <it>base</it> scope that helps define a new version of the inequality formula in the scope <it>stricter</it> by fallbacking to the base during its implementation.</p>

<pre><code class="language-cpp">base=new;stricter = {
    pop(super); //remove
    (x)<(y) := {
        base: ((x)<((y)-(1))) //computation under the base scope
    };
    new
};
comp = stricter:(1)<(2); //test a comparison under the new scope
print(comp)
</code></pre>

      </section>
      </section>
      
      <section id="common-expressions">
        <h1>Common expressions</h1>
        <p>NS is shipped with several built-in expressions that you can use.</p>
		
		
        <section id="io">
          <h4>I/O</h4>
          <p>Two base operations are provided for command line inputs and outputs: print and read. The first prints any kind of value, whereas the second reads a string from the console while displaying a message. Use them as in the following snippet.</p>

<pre><code class="language-cpp">name = read("Please give your name: ");
print("Hello "+name+"!");
</code></pre>
        </section>
        
        <section id="control-flow">
          <h4>Control flow</h4>
          <p>NS provides conditions and loops. Recall that assignments within bracketed scopes do not escape to parents, but conditions are also scopes to be evaluated. For example, the following snippet prints the squares of all integers less than 10 without exposing any internally generated variables; the loop's condition is responsible for iterating through the integeres by changing the superscope's iterated variable, and the body performs safe assignments.</p>

<pre><code class="language-cpp">i=-1;
while(i=i+1;i<10) {
	i squared = i*i;
	print(i squared);
}
</code></pre>

        </section>
		  

        </section>
        
        <section id="running-files">
          <h4>Running files</h4>
          <p>TODO</p>
        </section>
        
        <section id="errors">
          <h4>Errors</h4>
          <p>Syntax and logical errors are caught with a try command; this takes a scope as an argument and ruturns either its outcome or the error. To run code that prevents side effects on non-objects, enclose error-prone code in brackets like this;
<pre><code class="language-cpp">error = try {
	x = 1;
	y = x + z;//non-existing variable z
};
print(error);
</code></pre> 
		  
		  For example, the following snippet implements NS's command line interface with error catching for each command.</p>
<pre><code class="language-cpp">cli = 1;
exit := (cli = 0;'NS command line terminated.');
output = ( //keep scope modifications with parentheses
	while(cli) (
		line = read('> ');
		try(run(line))
	)
);
print(output);
</code></pre>		  

        </section>
      </section>
	  
	  
	  
	  
      
      <section id="high-order-features">
        <h1>High Order Features</h1>
        <p>NS offers advanced features like runtime parsing and metaprogramming. Runtime parsing involves tokenizing and parsing source code into an abstract syntax tree. Metaprogramming allows you to work with unevaluated scopes and define lambda expressions.</p>
		
        <section id="runtime-parsing">
          <h4>Runtime parsing</h4>
          <p>Before looking at more complex features, you need to understand how NS performs internal computations;
		  source code in textual form is tokenized (e.g., 'while(i<10)' is split to tokens 'while' '(' 'i' '<' '10')) and parsed into an abstract syntax tree of <b>only core features</b>. This is analogous to a compilation process, with the difference that it does not provide bytecode but an internal representation. To account for expressions, which can be dynamically defined and depend on the scope, unparsed expressions are retained as they are.</p>
		  
		  <p>Scope definitions using parentheses or brackets of the unparsable expressions may have been correctly parsed and reside alongside the yet-uncomplied tokens. Tokenization is finalized and does not need to rerun, but it is yet unclear how the expression should be interpreted, as it may comprise nested expressions. For example, 1+2*3 can not be immediately parsed, because the meaning of * and + needs to be extracted from the scope running the expression in the end.
		  </p>
		  
		  <p>Unparsed expression are parsed at the first point where their values is retrieved, and to make complex code run fastly the outcome of parsing is retained for future use.</p>
        </section>
		
		
        <section id="expression-overloading">
          <h4>Expression overloading</h4>
          <p>NS supports expressions with the same syntax that compute differently for different arguments. 
		  Doing this is done with a fallback into each argument's scope (this has as supperscope the expression's calling scope). For the arguments this is applied, the fallback should compute to either true (1) or false (0), given whether an argument being checked is accepted or not. The following example shows how to declare different implementations. 
		  </p>
		  
		  <pre><code class="language-cpp">
		  Complex(re,im):= {class='complex'; new};
		  (a:try class is 'complex') + (b:try class is 'complex') := Complex(a.re+b.re, a.im+b.im);
		  (a:try class is 'complex') - (b:try class is 'complex') := Complex(a.re-b.re, a.im-b.im);
		  (a:try class is 'complex') * (b:try class is 'complex') := Complex((a.re*b.re)-(a.im*b.im), (a.re*b.im)+(a.im*b.re));
</code></pre>
	
        </section>
		
		
        <section id="metaprogramming">
			<h4>Metaprogramming</h4>
			<p>Metaprogramming refers to the ability of a program to manipulate and generate code dynamically. In NS, metaprogramming is achieved by passing unevaluated scopes as expression arguments. Unevaluated scopes are essentially blocks of code that are not executed immediately, but can be evaluated later when needed. You can think of them as code templates. Declare that an expression argument should remain unevaluated by using double parenthesis. To execute an unevaluated scope pass it as an agrument to the run function. Here is an example:</p>
			
			<pre><code class="language-cpp">sequence((first))((second)) := (
	print("first");
	run(first);
	print("second");
	run(second)
);

sequence(x=1;print(" ...done"), x=2;print(" ...done")); //don't forget that , is parsed as )(
</code></pre>	


		<p>Unevaluated scopes can be returned with lambda expressions, which you can define like in the following example:</p>
		
		<pre><code class="language-cpp">lambda((code)) := {core}; //just return the unevaluated scope given as input
condition tight = lambda(x<10); // does not run immediately
condition loose = lambda(x<100); // does not run immediately
magnitude(x, condition) := {
	if(run(condition)) {  // or if(condition) as the latter already evaluates conditions
		print("small");
	}
	else {
		print("large");
	}
};
magnitude(20, condition tight);
magnitude(20, condition loose);
</code></pre>


		
        <section id="functional-programming">
			<h4>Functional programming</h4>
		<p>Functional programming is a paradigm that treats computation as the evaluation of mathematical functions, and avoids changing state and mutable data. While NS doesn't have traditional functions, it generalizes the same principles to expressions by letting them enclose appropriate methods to be called. For example:</p>
		
		<pre><code class="language-cpp">condition tight = {call(x):={x<10};new}; // create functional types with different method names
condition loose = {call(x):={x<100};new};
magnitude(value, condition) := {
	if(condition:call value) {  // failback (:) avoids using any x from magnitude in the condition 
		print("small");
	}
	else {
		print("large");
	};
};
magnitude(x,condition) := {print(condition);if(condition: call x) {print("small");}else{print("large");};};
magnitude(20, condition tight);  // small
magnitude(20, condition loose);  // large
</code></pre>
			
			
		</section>
		
		
		</section>
		
		
		
      
      <section id="new-scope-files">
        <h1>New scope files (aka libraries)</h1>
        <p>You can set the outcome of <a href="#running-files">running a file</a> to a variable. Files run in their parent scope, which means that you need to either gain all their declarations with a simple run or obtain their declaration from a bracket scope. To support this, return new at the end of runnable files. Consider the scope file utils.ns with contents:</p>
		
		<pre><code class="language-cpp">sqr(x) := x*x;
pi = 3.14159;
new
</code></pre>	
		
		<p>To avoid compromising declaration safety, obtain the file's expression with brackets, like this:</p>
		
		<pre><code class="language-cpp">utils = {run(x*x)};  // you may add try at the beginning of this line
x = 2;
print(utils:sqr(2)); // 4
</code></pre>	

		<p>NS comes along with several scope files that implement popular functionalities using <a href="#metaprogramming">metaprogramming</a>. These are presented below.</p>
		
		
        <section id="list">
          <h4>list.ns</h4>
          <p>This scope file lets you define lists, access element values via natural number identifiers, and set their element values. It also defines a for each loop. Internally, lists are lambda scopes and can be used as such (their elements are computed sequentially, and their last element is yielded as output). You can set any value to elements, including other lambda scopes, such as other lists.</p>
		  
		  
		  <pre><code class="language-cpp">list = {run('list.ns')};
		  
list: {  
	x = list{'a';'b';'c'}; // list with three elements
	print(size(x)); // 3
	y = x[0]; // enter the scope to access its defined expressions
	print(x[0]); // a
	x[0] ~ 1024; // set list element
	print(x[0]); // 1024
	print(x); // the last element of the list
	for each i in x do {print(i);}; // 1024  b  c
}
</code></pre>

		
		<div class="alert alert-info" role="alert">
			Use the nums scope for fast array computations.
		</div>


		</section>
		
		
        <section id="dict">
          <h4>dict.ns</h4>
          <p>This scope file lets you define dictionaries with hashable keys.</p>
		  
		  
		  <pre><code class="language-cpp">list = {run('list.ns')};
		  
list: {  
	x = list{'a';'b';'c'}; // list with three elements
	print(size(x)); // 3
	y = x[0]; // enter the scope to access its defined expressions
	print(x[0]); // a
	x[0] ~ 1024; // set list element
	print(x[0]); // 1024
	print(x); // the last element of the list
	for each i in x do {print(i);}; // 1024  b  c
}
</code></pre>

		</section>

    </main>
  </div>
</div>



</div>



</body>
</html>