<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NS language</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
	<link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
	<style>
    .sidebar {
      position: fixed;
	  width:200px;
      top: 12px;
      bottom: 0;
      left: 0px;
      z-index: 100;
      padding: 48px 0;
      background-color: #f8f9fa;
    }
	
	.navbar {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    .main-content {
      margin-left: 200px; /* Adjust this to match sidebar width */
      margin-top: 56px; /* Height of the navbar */
    }
	
	.smaller-font {
		margin-left: 10px;
		margin-top: -10px;
		font-size: 0.8em; /* Adjust the value as needed */
	}
  </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
	<a class="navbar-brand" href="#">
		<img src="ns.png" alt="NS" width="50">
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="navbarNav">
		<ul class="navbar-nav ml-auto">
			<li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="start.html">Get started</a></li>
			<li class="nav-item active"><a class="nav-link text-primary" href="syntax.html">Syntax</a></li>
			<li class="nav-item"><a class="nav-link" href="tutorials.html" data-page="tutorials">Tutorials</a></li>
		</ul>
	</div>
	</div>
</nav>


<div class="container main-content">
	

<div class="container-fluid mt-4">
  <div class="row">
    <!-- Sidebar -->
    <nav class="col-md-3 col-lg-2 d-md-block bg-white sidebar">
      <div class="position-sticky">
        <ul class="nav flex-column">
          <li class="nav-item">
            <a class="nav-link" href="#language-core">
              Language core
            </a>
            <ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#assignment-scope">Assignment scope</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#scopes-as-objects">Scopes as objects</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#define-expressions">Define expressions</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#scope-access">Scope access</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#common-expressions">
              Common expressions
            </a>
			<ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#io">I/O</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#control-flow">Control flow</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#running-files">Running files</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#errors">Errors</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#high-order-features">
              High order features
            </a>
			<ul class="nav flex-column ml-3">
              <li class="nav-item"><a class="nav-link smaller-font" href="#runtime-parsing">Runtime parsing</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#functional-programming">Functional programming</a></li>
              <li class="nav-item"><a class="nav-link smaller-font" href="#arithmetics">Metaprogramming</a></li>
            </ul>
          </li>
		  
        </ul>
      </div>
    </nav>

    <!-- Main content -->
    <main class="col-md-9 ml-sm-auto col-lg-10 px-md-4">
	
      <div class="pt-3 pb-2 mb-3">
		<div class="jumbotron">
			<h1 class="display-4">NS syntax</h1>
		</div>
      </div>
      
      <section id="language-core">
        <h1>Language core</h1>
        <p>NS emphasizes the concept of treating scopes, blocks of code, and objects interchangeably.
		This creates an interface that is easy to learn but provides many powerful options on designing
		code, including the ability of programs to alter their own source code. 
		</p>
        <section id="assignment-scope">
          <h4>Assignment scope</h4>
		  <p>NS refers to <it>scopes</it> as blocks of code with clearly understood rule of which variables or formulas/programming commands they can access. We we talk about formulas later, and now focus on setting and accessing variables.
		  </p>
		  <p>Starting from a top-level scope, new ones can be declared inside it and separated by a semicolon. Scopes can be enclosed inside brackets or parentheses. Parentheses can also be ommited when running a single formula, such as assignment or printing. Of the two types, <it>bracketed scopes do not modify external variables</it> unless they explicitly access them via objects (more on this later). The following snippet demonstrates bracket and parentehesis scopes in action.
		  </p>

<pre><code class="language-cpp">x = 0;
{
	x = 1;
	print(x); //0
};
print(x); //1
(
	x = 1;
	print(x); //0
);
print(x); //1</code></pre>
        
		<p>The last expression of scopes does not need to be followed by a semicolon and is actually a returned value. For example, you can have a large bracketed scope that only outputs a value at the end. In general, prefer using bracketed scopes for safe assignments, but parentheses scopes have lesser overhead. The following snippet demonstrates assignment of values from scopes.</p>
		
<pre><code class="language-cpp">y = {
	x = 1;
	x
};
print(y); //1</code></pre>
		
        </section>
		
		

        <section id="scopes-as-objects">
          <h4>Scopes as objects</h4>
          <p>Scopes can view themselves like objects that hold their assigned variables. This view is obtained with the <it>new</it> variable. Object fields can be retrieved with the dot operator. What actually happens is a little more nuanced (the dot operator is one of the available types of scope access), but this understanding suffices to get a first example going. You can naturally return <it>new</it> from the scope itself to effectively generate an object, as demonstrated in the snippet below.</p>
<pre><code class="language-cpp">point = {
	x = 1;
	y = 2;
	new
};
print(point.x); //1
print(point.y); //1</code></pre>
		
		<p>All scopes have some additional variables (<it>super,fallback,failback,fallfront</it>) that are internally consulted for retrieval of variable values. First let as look at <it>super</it>; this is the superscope, that is scope in which <it>new</it> was originally constructed. This is the same as <it>new</it> for parentheses scopes, but is otherwise one level of hierarchy higher in a scope dependency hiererarchy.</p>
		
		<p>When trying to read a variable and this does not exist in the scope, this is retrieved from the superscope instead. Scopes always write variables on <it>new</it>, regardless of where they are made to read from. The following snippet reads z from the superscope to assign it to the scope. The value of z remains in the superscope, and can actually be retrieved from objects themselves.</p>
		
<pre><code class="language-cpp">z = 1;
point = {
	x=z;
	y=2;
	new
};
z = 0;
print(point.super.z); //0
print(point.x); //1
print(point.super.z); //1</code></pre>

        </section>
        
		
        <section id="define-expressions">
          <h4>Define expressions</h4>
          <p>The final NS core operation is assignment of callable formulas. These define any kind of predicate-based notation.Basically, you need to write a textual expression to be matched *including expressions with multiple predicates seperated by spaces*, and any arguments need to be enclosed parentheses. When formulas run, they do so under a scope of their argument values. For example, you can define a constructor for class objects like in the following snippet.<p> 

<pre><code class="language-cpp">Point(x,y,z) := { // x, y, z automatically accessed from super
    new
};
</code></pre>

		<p>If formula implementations are not scoped into brackets, internal assignments are transferred to their superscope too per normal (the arguments themselves are never assigned, so they will not leak). For example set f(value):=(f=value) is equivalent to set f(value):={super.super.f=value}, where in the last expression the first superscope are the arguments and only this one's supercope is the object. In the following snippet, norm squared is a method name that includes spaces.

<pre><code class="language-cpp">Point(x,y,z) := {
    norm squared:=x*x + y*y + z*z; 
    shrink(a) := (x=x*a;y=y*a;z=z*a;); // if you want to keep track of the last argument value within Point set a=a
    new
};
A = Point(0,0,1);
print(A.norm squared); //1
</code></pre>


		<p>The snippet uses tuples of variables like (x,y,z), but keep in mind that NS considers the comma as a shorthand and converts the expression to (x) (y) (z) under the hood. This maintains the convention that the last value of scopes is returned. Method definitions reside within their own scope. Polymorphism is supported by declaring new methods with different arguments as previous ones, like in the following snipper.

<pre><code class="language-cpp">Point(x,y,z) := {new};
Point(x,y) := Point(x,y,0);
A = Point(1,1);
print(A.norm squared); //2
</code></pre>
	<p>Use objects to pass keyword arguments or arguments that you don’t want to remain in the object’s scope.</p>

        </section>
        
		
        <section id="scope-access">
          <h4>Scope access</h4>
          
		<p>Previously, we called the dot operator as a type of scope access, so let us see what this is all about. In truth, a.b is the non-parentheses version of a.(b), in which b is made to run within the scope of a, but can also be a code block. That is, you may have a complicated scope modification inside the parentheses. Of course, you can always use brackets instead of parentheses to perform any kind of operations using the scope's values without. This is demonstrated in the snippet bellow.</p>
		
<pre><code class="language-cpp">point = {
	x=1;
	y=2;
	new
};
point.x = 5; // the same as point.(x=5);
print(point.x); //5

point.(x=1; y=1;);
print(point.x); //1
print(point.y); //1

derived = point.{y=6;new}; //super of derived is the point
print(derived.x); //1
print(derived.y); //6
print(derived.super.x); //1</code></pre>
		
		<p>In the scenarios visited above, it was always clear whose scope variables were gathered;
		each variable name could be found in only one scope and retrieved from that one. 
		The variable scope is also clear during assignment, even if there are the same names across multiple scopes, only the variable residing on the current <it>new</it> object is set.
		However, things get trickier when the same variables exist in multiple scopes, as in snippet bellow, where it is uncertain whether after accessing the scope a we should use its own x or parent's version of; for this reason an error is created. Recall that the accessed part is also a scope and not some simple field getter. Other programming languages do not encounter this issue, because they do not support the more dynamic scope access of.
		</p>
<pre><code class="language-cpp">x = 1;
a = {
	x = 0;
	new
};
try(print(a.x)); //this will catch the created error
</code></pre>

		<p>The dot operation uses the accessor scope (i.e., from which scope access is called) as the <it>failback</it> of the scope being entered (i.e., the scope of a). This is what NS calls an operation that catches conflicting concepts. There are two other alternatives, the <it>fallback</it> and <it>fallfront</it> accessors. The former is denoted with a colon (:) and does not let the accessor scope affect the one being entered. The latter is denoted with a sharp (#) and forces all variables to be retrieved from the accessor scope or its superscopes. If you want to treat scopes as simple objects from which to read or write, use the fallback when reading and the fallfront when writting, as in the following snippet.</p>
		
<pre><code class="language-cpp">x = 1;
a = {
	x = 0;
	new
};
print(a:x); //0
a#x = x;
print(a:x); //1
</code></pre>

		<div class="alert alert-info" role="alert">
		 Having three types of accessors complicates object field operations, but clarifies which scope decides how expressions are evaluated.
		</div>
		
		<div class="alert alert-info" role="alert">
		 The symbols =, :=, ., '#', ':' have the same priority and the leftmost one is applied first.
		</div>
		
		
	<p>The following example shows how to override a formula using the fallback operation. Basically, it stores a <it>base</it> scope that will help define a new version of the inequality formula in the scope <it>stricter</it> by fallbacking on the base during implement. Fallback to `stricter` to run its version of inequality.</p>


<pre><code class="language-cpp">base=new;stricter = {
    pop(super); //remove
    (x)<(y) := {
        base: ((x)<((y)-(1))) //computation under the base scope
    };
    new
};
comp = stricter:(1)<(2); //test a comparison under the new scope
print(comp)
</code></pre>

	<p>In both cases, using a fallfront (#) instead of a fallback (:) would fail; it would respectively create an infinite recursion, and apply the base inequality.</p>
      </section>
      </section>
      
      <section id="common-expressions">
        <h1>Common expressions</h1>
        <p>NS is shipped with several built-in expressions that you can use.</p>
		
		
        <section id="io">
          <h4>I/O</h4>
          <p>Two base operations are provided for command line inputs and outputs: print and read. The first prints any kind of value, whereas the second reads a string from the console while displaying a message. Use them as in the following snippet.</p>

<pre><code class="language-cpp">name = read("Please give your name: ");
print("Hello "+name+"!");
</code></pre>
        </section>
        
        <section id="control-flow">
          <h4>Control flow</h4>
          <p>NS provides conditions and loops. Recall that assignments within bracketed scopes do not escape to parents, but conditions are also scopes to be evaluated. For example, the following snippet prints the squares of all integers less than 10 without exposing any internally generated variables; the loop's condition is responsible for iterating through the integeres by changing the superscope's iterated variable, and the body performs safe assignments.</p>

<pre><code class="language-cpp">i=-1;
while(i=i+1;i<10) {
	i squared = i*i;
	print(i squared);
}
</code></pre>

        </section>
		  

        </section>
        
        <section id="running-files">
          <h4>Running files</h4>
          <p>TODO</p>
        </section>
        
        <section id="errors">
          <h4>Errors</h4>
          <p>Syntax and logical errors are caught with a try command; this takes a scope as an argument and ruturns either its outcome or the error. To run code that prevents side effects on non-objects, enclose error-prone code in brackets like this;
<pre><code class="language-cpp">error = try {
	x = 1;
	y = x + z;//non-existing variable z
};
print(error);
</code></pre> 
		  
		  For example, the following snippet implements NS's command line interface with error catching for each command.</p>
<pre><code class="language-cpp">cli = 1;
exit := (cli = 0;'NS command line terminated.');
output = ( //keep scope modifications with parentheses
	while(cli) (
		line = read('> ');
		try(run(line))
	)
);
print(output);
</code></pre>		  

        </section>
      </section>
	  
	  
	  
	  
      
      <section id="high-order-features">
        <h1>High Order Features</h1>
        <p>NS lets you extend how it behaves.</p>
		
        <section id="runtime-parsing">
          <h4>Runtime parsing</h4>
          <p>Before looking at more complex features, you need to understand how NS performs internal computations;
		  source code in textual form is tokenized (e.g., 'while(i<10)' is split to tokens 'while' '(' 'i' '<' '10')) and parsed into an abstract syntax tree of <b>only core features</b>. This is analogous to a compilation process, with the difference that it does not provide bytecode but an internal representation. To account for expressions, which can be dynamically defined and depend on the scope, unparsed expressions are retained as they are.</p>
		  
		  <p>Scope definitions using parentheses or brackets of the unparsable expressions may have been correctly parsed and reside alongside the yet-uncomplied tokens. Tokenization is finalized and does not need to rerun, but it is yet unclear how the expression should be interpreted, as it may comprise nested expressions. For example, 1+2*3 can not be immediately parsed, because the meaning of * and + needs to be extracted from the scope running the expression in the end.
		  </p>
		  
		  <p>Unparsed expression are parsed at the first point where their values is retrieved, and to make complex code run fastly the outcome of parsing is retained for future use.</p>
        </section>
		
		
        <section id="functional-programming">
			<h4>Functional programming</h4>
			<p>In addition to object immutability, which is a choice that a programmer can adhere to, functional programming also requires the ability to pass methods as arguments to other methods. NS does not have the concept of a method; only the more general idea of expressions. However, these are not identifiable from one keyword. There are two ways with which NS works around this restriction. </p>
			
			<p>The first option is ideal when creating expressions; just add another set of parentheses around arguments that are expected to be unevaluated scopes. Unevaluated scopes can then be run with the namesake method (running is polymorphised so that it runs code or files for string inputs, but evaluates expressions otherwise). This is demonstrated in the following snippet, which first creates two unevaluated scopes and then runs them within the sequence expression.</p>
			
			<pre><code class="language-cpp">sequence((first))((second)) := (
	print("first");
	run(first);
	print("second");
	run(second)
);

sequence(x=1;print(" ...done"), x=2;print(" ...done")); //don't forget that , is parsed as )(
</code></pre>	


		<p>Using the above, we can define a lambda scope, which is an unevaluated scope to be evaluated later. The lambda expression needs to either be declared by you, as in the following example snippet, or loaded from a library, such as utils.</p>
		
		<pre><code class="language-cpp">lambda((code)) := {core}; //just return the unevaluated scope given as input
condition tight = lambda(x<10); // does not run immediately
condition loose = lambda(x<100); // does not run immediately
magnitude(x, condition) := {
	if(run(condition)) {  // or if(condition) as the latter already evaluates conditions
		print("small");
	}
	else {
		print("large");
	}
};
magnitude(20, condition tight);
magnitude(20, condition loose);
</code></pre>

		
		<p>When you do not need to define expressions with unevaluted snippets as inputs, creating an object with a specifically defined expression pattern can be more straightforward for functional programming. This is shown in the following snippet, where you just need to select the same call definition for your interchangable functional components; in fact, you should use names other than call to give an in-built typing constraint to what type of task you are computing.</p>
		
		<pre><code class="language-cpp">condition tight = {call(x):={x<10};new};
condition loose = {call(x):={x<100};new};
magnitude(x, condition) := {
	if(condition: call x) {  // or if(condition) as the latter already evaluates conditions
		print("small");
	}
	else {
		print("large");
	};
};
magnitude(x,condition) := {print(condition);if(condition: call x) {print("small");}else{print("large");};};
magnitude(20, condition tight);  // small
magnitude(20, condition loose);  // large
</code></pre>
			
			
		</section>
		
		
		</section>


    </main>
  </div>
</div>



</div>



</body>
</html>